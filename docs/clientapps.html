<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>AlpacaPi - Client Apps</title>
	<link rel="stylesheet" href="styles.css">
</head>
<body>
	<div class="container">
		<header>
			<h1>AlpacaPi</h1>
			<h2>Client Apps</h2>
		</header>

		<nav>
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="skytravel.html">SkyTravel</a></li>
				<li><a href="drivers.html">Drivers</a></li>
				<li><a href="clientapps.html">Client Apps</a></li>
				<li><a href="moonphase.html">Moon Phase</a></li>
				<li><a href="skyimage.html">SkyImage</a></li>
				<li><a href="aavsoTargetTool.html">AAVSO</a></li>
			</ul>
		</nav>

		<main>
			<h2>Client applications</h2>
			<p>Once you have drivers running, you need an application to control it.
			The drivers have no direct user interface are designed to be only talked to through a network connection.
			You can use a web browser to read data but a web browser will not let you send commands.</p>

			<p>AlpacaPi includes stand alone client applications for the following devices.</p>
			<ul>
				<li>Camera</li>
				<li>Dome</li>
				<li>Filter Wheel</li>
				<li>Focuser</li>
				<li>Switch</li>
			</ul>

			<p>As stated above, a client application needs to know what device to talk to.
			You could specify the exact IP address and port if you know it, or use the discovery protocol.
			One thing to note, the discovery protocol only works on your local subnet.
			For most people this is fine, but if you want to control a REMOTE device, you will need to specify the IP and port.</p>

			<p>The client would issue a discovery protocol query and look for the devices it knows how to talk to.
			In this example we are running my camera Gui program. As you can see from the client dump above,
			it has found a camera at IP 192.168.1.164 on port 6800.
			It also noticed that there was a filter wheel on the same device.
			This camera application is smart enough to know how to talk to both of them.
			If a filter wheel does not exist, that interface is not displayed as in the 2nd image.</p>

			<hr>

			<p><strong>Building Client Apps:</strong> Client applications are built automatically when you run <code>setup_complete.sh</code>
			and choose to build AlpacaPi. The setup script will detect your OpenCV version (3 or 4) and build the appropriate versions.</p>

			<p>If you need to build client apps manually after installation, you must have OpenCV installed first.
			The setup script handles OpenCV installation automatically. To build manually:</p>
			<p>For OpenCV 4:</p>
			<pre><code>make cameracv4
make domectrlcv4
make focusercv4
make switchcv4</code></pre>
			<p>For OpenCV 3:</p>
			<pre><code>make camera
make domectrl
make focuser
make switch</code></pre>
			<p><strong>Note:</strong> It's recommended to use <code>setup_complete.sh</code> which handles all dependencies and builds
			everything automatically. See the <a href="index.html">installation page</a> for details.</p>

			<div class="image-gallery">
				<img src="images/Camera-newt16-screenshot.jpg" alt="Camera GUI with filter wheel">
				<img src="images/Camera-wo71-screenshot.jpg" alt="Camera GUI without filter wheel">
			</div>

			<p>My focuser application is specifically designed to look exactly like the MoonLite NiteCrawler application.
			As in the case of the camera and the filter wheel.
			This app recognizes that there is both a focuser and a rotator on the same device.
			It will also work with the normal MoonLite focuser controller that does not have the rotator.</p>

			<p>The image on the right is for a focuser that does not have an integrated rotator.
			Again, designed to look just like the MoonLite application.</p>

			<div class="image-gallery">
				<img src="images/NiteCrawler-newt16-screenshot.jpg" alt="NiteCrawler with rotator">
				<img src="images/Moonlite-jetson-screenshot.jpg" alt="Moonlite without rotator">
			</div>
		</main>
	</div>
</body>
</html>
